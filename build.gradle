/*
 * Copyright 2009-2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import org.apache.tools.ant.filters.ReplaceTokens

//===========================================
// Basic
//===========================================

apply plugin: 'groovy'
apply plugin: 'idea'
apply plugin: AnsiColorConsoleLogPlugin

defaultTasks 'clean', 'test', 'dist' // whole tasks

// keep same as groovy-core
sourceCompatibility = 1.6
targetCompatibility = 1.6

repositories {
    mavenCentral()
    maven { url "http://repository.codehaus.org" }
    maven { url "http://snapshots.repository.codehaus.org" }
}

configurations {
    // dependencies for archives are picked at compile configuration
    compile.extendsFrom archives
}

dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.3.3'
    compile 'commons-cli:commons-cli:1.2'
    archives 'net.java.dev.jna:jna:4.1.0'
    testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
    testRuntime 'cglib:cglib-nodep:2.2.2'     // for spock: enables mocking of classes (in addition to interfaces)
    testRuntime 'org.objenesis:objenesis:1.3' // for spock: enables mocking of without default constructor (together with CGLIB)
}

def defaultEncoding = 'UTF-8'
tasks.withType(AbstractCompile).each { it.options.encoding = defaultEncoding }
tasks.withType(GroovyCompile).each { it.groovyOptions.encoding = defaultEncoding }

//===========================================
// Tasks
//===========================================

//----------------------------------
// copySpec

def binSpec = copySpec {
    from("$projectDir") {
        include "*.txt"
        include "*.md"
    }
    into('lib') {
        from configurations.archives
        from "$buildDir/libs"
    }
    into('platforms') {
        fileMode = 0755
        from "$buildDir/platforms"
        exclude "local"
    }
}

def srcSpec = copySpec {
    from("$projectDir") {
        include "*.txt"
        include "*.md"
        include "settings.gradle"
        include "build.gradle"
        include "gradle.properties"
        include "Makefile"
    }
    into("src") {
        from "$projectDir/src"
    }
    into("contrib") {
        from "$projectDir/contrib"
    }
    from("$projectDir") {
        fileMode = 0755
        include "gradlew*"
    }
    into("gradle") {
        from "$projectDir/gradle"
    }
}

//----------------------------------
// Build

jar {
    baseName = project.name
    inputs.dir file("$projectDir/src/main")
    outputs.dir file("$buildDir/libs")
}

task compileGroovy(overwrite: true, type: Copy) {
    // Groovy sources shouldn't be compiled in order to avoid a trouble
    // of unmatch of Java version between compile-time and runtime.
    // Compiled Groovy classes under src/main/groovy directory are used only by unit tests.
    // Instead, Groovy sources including JAR file under build/executables directory
    // are used by integration tests.
    into "$buildDir/classes/main"
    from "$projectDir/src/main/groovy"
    filter(ReplaceTokens, tokens: ["GROOVYSERV_VERSION": project.version])
}

task compileGo {
    doLast {
        ansi.printlnAsInfo ">> Compiling Go sources..."
        file("$projectDir/src/main/go").eachFileMatch(groovy.io.FileType.FILES, ~/.*\.go/) { srcFile ->
            // for local environment by default for testing
            def outputFileName = srcFile.name - '.go'
            def env = [:]
            if (isWindows()) {
                outputFileName += ".exe"
                env += [GOOS: "windows", GOARCH: "386"] // using 386 binary even in 64-bit Windows
            }
            compileGoSrc(srcFile, outputFileName, "local")
        }
    }
}

task crossCompileGo {
    doLast {
        ansi.printlnAsInfo ">> Cross compiling Go sources..."
        file("$projectDir/src/main/go").eachFileMatch(groovy.io.FileType.FILES, ~/.*\.go/) { srcFile ->
            [
                [GOOS: "darwin", GOARCH: "amd64"],
                [GOOS: "linux", GOARCH: "386"],
                [GOOS: "linux", GOARCH: "amd64"],
                [GOOS: "windows", GOARCH: "386", ext: ".exe"],
            ].each { platform ->
                def outputFileName = srcFile.name - '.go' + (platform.ext ?: '')
                compileGoSrc(srcFile, outputFileName, "${platform.GOOS}_${platform.GOARCH}", platform.subMap('GOOS', 'GOARCH'))
            }
        }
    }
}

task assemble(overwrite: true, dependsOn: ['jar', 'compileGo'])

task executables(type: Copy, dependsOn: ['assemble']) {
    destinationDir = file("$buildDir/executables")
    inputs.dir file("$projectDir/src/main")
    outputs.dir destinationDir
    with binSpec

    // for testing
    into('bin') {
        fileMode = 0755
        from "$buildDir/platforms/local"
    }
}

//----------------------------------
// Distribution

task dist(dependsOn: ['distBin', 'distSrc'])

task distBin(type: Zip, dependsOn: ['assemble', 'crossCompileGo']) {
    inputs.dir file(projectDir)
    baseName = project.name
    classifier = 'bin'
    into "$baseName-$version"
    with binSpec

    // for multiple platoforms
    into('bin') { // scripts with filter
        fileMode = 0755
        from "$projectDir/src/main/sh", {
            include "groovyserv-setup-bin.sh"
            include "_common.sh"
        }
    }
}

task distSrc(type: Zip) {
    inputs.dir file(projectDir)
    baseName = project.name
    classifier = 'src'
    into "$baseName-$version"
    with srcSpec
}

//----------------------------------
// Test

task test(overwrite: true, dependsOn: ['unitTest', 'integrationTest'])

task unitTest(type: Test) {
    reports.html.destination = file("$buildDir/reports/unit")
    reports.junitXml.destination = file("$buildDir/test-results/unit")

    // Unfortunatelly, these cause no effect for UP-TO-DATE skipping due to systemProperty call in doFirst.
    inputs.dir file("$projectDir/src/main/groovy")
    outputs.dir file("$buildDir/test-results/unit")

    doFirst {
        // This causes running this task even though UP-TO-DATE skipping condition is met.
        systemProperty 'spock.configuration', "spock/unit.groovy"
    }
}

task integrationTest(type: Test, dependsOn: 'executables') {
    mustRunAfter "unitTest"

    reports.html.destination = file("$buildDir/reports/integration")
    reports.junitXml.destination = file("$buildDir/test-results/integration")

    // Unfortunatelly, these cause no effect for UP-TO-DATE skipping due to systemProperty call in doFirst.
    inputs.dir file("$projectDir/src")
    outputs.dir file("$buildDir/test-results/integration")

    def binDir = normalizePath(file("${buildDir}/executables/bin"))
    def clientExecutableExpression = "$binDir/groovyclient"
    def serverExecutableExpression = "$binDir/groovyserver"

    doFirst {
        // This causes running this task even though UP-TO-DATE skipping condition is met.
        systemProperty 'spock.configuration', "spock/integration.groovy"

        // prop for TestUtils
        systemProperties 'groovyserv.executable.client': clientExecutableExpression
        systemProperties 'groovyserv.executable.server': serverExecutableExpression

        restartGroovyServer()
    }
    doLast {
        shutdownGroovyServer()
    }
}

//------------------------
// Gradle wrapper

task wrapper(type: Wrapper) {
    gradleVersion = '2.0'
}

//------------------------
// Documents

task docs << {
    executeCommand('git', 'checkout', 'docs')
    executeCommand('make', 'clean', 'html')
    executeCommand('git', 'checkout', 'gh-pages')
    copy {
        into "$projectDir"
        from "$projectDir/build/docs"
    }
}

//===========================================
// Helper
//===========================================

def restartGroovyServer() {
    ansi.printlnAsInfo ">> Restarting groovyserver..."
    handleServer(["-r", "-v"])
}

def shutdownGroovyServer() {
    ansi.printlnAsInfo ">> Shutting down groovyserver..."
    handleServer(["-k"])
}

def handleServer(List options) {
    def binDir = normalizePath(file("${buildDir}/executables/bin"))
    def groovyserverPath = "$binDir/groovyserver"
    executeCommand([groovyserverPath, * options])
}

def executeCommand(List command, Map env = [:]) {
    ansi.printlnAsInfo ">> Executing command..."
    ansi.printlnAsInfo "\$ ${command.join(' ')}"
    def pb = new ProcessBuilder(command as String[])
    pb.environment().with {
        if (env) putAll(env)
        remove('GROOVYSERV_HOME') // unset GROOVYSERV_HOME (which may be set by GVM) for a process invoked by gradle directly
    }
    def p = pb.start()
    p.consumeProcessOutput(System.out as OutputStream, System.err as OutputStream) // Gradle's wrapper stream writes nothing to console
    int statusCode = p.waitFor()
    if (statusCode != 0) {
        ansi.printlnAsError "Exit for status code $statusCode"
        throw new GradleScriptException("Exit for status code $statusCode while executing '${command.join(' ')}'", null)
    }
}

def normalizePath(File file) {
    file.canonicalPath.replaceAll('\\\\', '/')
}

def isWindows() {
    ant.condition(property: "os", value: "windows") { os(family: "windows") }
    return ant.properties['os'] == "windows"
}

def compileGoSrc(File srcFile, String outputFileName, String platform, Map<String, String> env = [:]) {
    executeCommand(["go", "build", "--ldflags", "-X main.GroovyServVersion ${project.version}", "-o", "$buildDir/platforms/$platform/$outputFileName", srcFile.path], env)
}

